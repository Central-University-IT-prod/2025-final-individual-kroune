# Обоснование использование библиотек/решений

### kotlin

**Проблема:**

* выбор языка для написания приложения

**Варианты решений:**

* kotlin
* java
* другие

**Причины выбора:**

* более компактный код
* быстро развивается
* компилируется в jvm
* простой и приятный синтаксис
* null safety
* условие индивидуального тура требуют нативной разработки

### jetpack compose

**Проблема:**

* требуется выбрать способ написания ui

**Варианты решений:**

* jetpack compose
* xml

**Причины выбора:**

* декларативность
* более компактный код
* активно развивает и получает все большое использование
* более простой и интуитивный код
* отличная интеграция с функциями kotlin
* активно развивается google
* лучше знаком с ней
* поддержка мультиплатформы (на случай возможной миграции на kmm)

**Потенциальные проблемы:**

* менее качественный tooling
* более медленная работа при первой загрузке кода (потенциальное решение - baseline profile)
* активное изменение api

### kotlinx serialization

**Проблема:**

* сериализация/десериализация данных

**Варианты решений:**

* kotlinx serialization
* gson
* jackson
* moshi
* JSONObject

**Причины выбора:**

* отличная интеграция с kotlin
* не используется рефлексия (не возникает проблем с proguard и т.п.)
* поддержка разных форматов
* поддержка мультиплатформы (на случай возможной миграции на kmm)

### coroutines

**Проблема:**

* управление асинхронным кодом (колбэки, потоки и т.п.)

**Варианты решений:**

* RxJava
* Coroutines
* Threads

**Причины выбора:**

* нативная интеграция с Kotlin
* мощная абстракция
* читаемость кода
* легковесность
* простота отмены задач
* поддержка мультиплатформы (на случай возможной миграции на kmm)

### ktor

**Проблема:**

* сетевые запросы с поддержкой асинхронности

**Варианты решений:**

* Retrofit
* ktor
* Volley

**Причины выбора:**

* kotlin - first
* большее знакомство
* поддержка мультиплатформы (на случай возможной миграции на kmm)

### decompose

**Проблема:**

* навигация

**Варианты решений:**

* compose navigation
* decompose

**Причины выбора:**

* type safety
* изоляция логики
* простота декомпозиции кода на сложных экранах

### AndroidX Crypto

**Проблема:**

* Безопасное хранение данных на устройстве в зашифрованном виде

**Варианты решений:**

* AndroidX Crypto
* Google Tink
* SQLCipher

**Причины выбора:**

* интеграция с Android Keystore
* минималистичный API

### Coil

**Проблема:**

* Coil
* загрузка и эффективное кэширование изображений

**Варианты решений:**

* Glide
* Fresco

**Причины выбора:**

* интеграция с kotlin
* эффективность работы
* удобная поддержка compose

### AndroidX Paging 3

**Проблема:**

* paging 3
* пагинация больших наборов данных

**Варианты решений:**

* ручное решение
* paging 2

**Причины выбора:**

* интеграция с flow
* простота использования

### Room

**Проблема:**

* эффективное локальное хранение структурированных данных

**Варианты решений:**

* Room
* SQLite Open Helper
* Realm

**Причины выбора:**

* проверка SQL на этапе компиляции
* миграции
* возможность интеграции с корутинами (при помощи -ktx пакета)